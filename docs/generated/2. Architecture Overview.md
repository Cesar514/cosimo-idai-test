# Architecture Overview

## System Context (C4 Level 1)

The primary actor is a researcher/developer who runs Pixi tasks or direct Python commands. The runtime coordinates planning and simulation, writes benchmark artifacts, and feeds screenshot/deck automation.

```mermaid
graph LR
  User[Researcher or Engineer]
  CLI[Pixi tasks and direct CLI]
  Runtime[robotics_maze runtime]
  Physics[PyBullet or MuJoCo]
  Results[results CSV Markdown screenshots]
  Deck[agents.pptx pipeline]
  Reports[coordination agent reports]

  User --> CLI
  CLI --> Runtime
  Runtime --> Physics
  Runtime --> Results
  Results --> Deck
  User --> Reports
```

## Container Architecture (C4 Level 2)

The repository is organized as task-scoped containers sharing a Python workspace.

```mermaid
graph TB
  subgraph Workspace
    Pixi[Root pixi.toml tasks]
    Wrapper[scripts/sim_runner.py]
  end

  subgraph RuntimeContainer
    Main[src/main.py]
    Gui[src/gui_setup.py]
    Maze[src/maze.py]
    PlannerRegistry[src/planners.py]
    Alt[src/alt_planners/*]
    Sim[src/sim.py]
    Robot[src/robot.py]
    Geometry[src/geometry.py]
  end

  subgraph EvalContainer
    Bench[src/benchmark.py]
    Tests[tests/test_core.py]
    Results[results/*]
  end

  subgraph ArtifactContainer
    Shot2D[generate_sim_screenshots.py]
    ShotMJ[generate_mujoco_screenshots.py]
    DeckTools[apply_ppt_assets.py and fix_ppt_full.py]
  end

  Pixi --> Wrapper --> Main
  Main --> Maze
  Main --> PlannerRegistry
  Main --> Alt
  Main --> Sim
  Sim --> Robot
  Sim --> Geometry
  Main --> Gui
  Bench --> Maze
  Bench --> PlannerRegistry
  Bench --> Alt
  Bench --> Results
  Tests --> Bench
  Shot2D --> Bench
  ShotMJ --> Bench
  Shot2D --> Results
  ShotMJ --> Results
  DeckTools --> Results
```

## Component Architecture (C4 Level 3)

`main.py` drives the run loop by composing loader strategies and a shared episode contract.

```mermaid
graph LR
  Args[CLI args] --> Parse[parse_args]
  Parse --> Config[RunConfig]
  Config --> MaybeGUI[apply_gui_setup optional]
  MaybeGUI --> LoadMaze[load_maze_generator]
  MaybeGUI --> LoadPlanner[load_planner]
  MaybeGUI --> LoadSim[load_simulator]
  LoadMaze --> EpisodeLoop[for each episode]
  LoadPlanner --> EpisodeLoop
  LoadSim --> EpisodeLoop
  EpisodeLoop --> Plan[planner.plan]
  EpisodeLoop --> SimRun[simulator.run_episode]
  SimRun --> Result[EpisodeResult]
  Result --> Summary[aggregate and exit code]
```

## Architectural Patterns

- `Registry pattern`: planner and heuristic lookup maps in `planners.py` and `heuristics.py`.
- `Adapter pattern`: `FunctionPlannerAdapter` normalizes function planners into the `Planner` protocol.
- `Plugin-by-convention`: loader attempts known module/symbol combinations before stubs.
- `Layered decomposition`: orchestration, domain logic, simulation, and artifact generation are separated by module boundaries.
- `Deterministic execution`: seed offsets and benchmark maze indexing preserve reproducibility.

## Key Design Decisions

1. Runtime supports fallback behavior instead of hard-failing optional integrations.
   - Rationale: preserve execution across environments with different physics/tooling availability.
   - Trade-off: silent fallback can obscure capability differences unless logs are reviewed.

2. Benchmark compares planners on a shared-success subset.
   - Rationale: comparable-time/path metrics remain fair when failures occur.
   - Trade-off: subset metrics can hide behavior on difficult mazes where planners diverge.

3. Planner output is normalized and path-validated before scoring.
   - Rationale: mixed return schemas from baseline/alt planners need a common contract.
   - Trade-off: richer planner-specific metrics are trimmed unless mapped explicitly.

4. Wrapper-based task entry (`scripts/sim_runner.py`) sanitizes passthrough args.
   - Rationale: avoid task-runner separator leakage (`--`) into runtime parsing.
   - Trade-off: root Pixi tasks cover common flows; advanced combinations use direct CLI.

## Module Breakdown

### Runtime Orchestration

- **Purpose**: Parse intent, resolve runtime components, execute episodes.
- **Key modules**: `scripts/sim_runner.py`, `src/main.py`, `src/gui_setup.py`.
- **Notable behavior**: GUI setup override path, URDF validation, per-episode seed derivation.

### Planning and Maze Domain

- **Purpose**: Build deterministic mazes and produce planner paths.
- **Key modules**: `src/maze.py`, `src/planners.py`, `src/alt_planners/`, `src/heuristics.py`.
- **Notable behavior**: baseline planner registry plus alternative planner implementations (`r1`-`r13`).

### Simulation and Robot Control

- **Purpose**: Convert plans to waypoints and run backend-specific episodes.
- **Key modules**: `src/sim.py`, `src/robot.py`, `src/geometry.py`.
- **Notable behavior**: backend preference order and deterministic non-physics fallback.

### Evaluation and Artifacts

- **Purpose**: Benchmark planners and produce consumable output artifacts.
- **Key modules**: `src/benchmark.py`, screenshot scripts, `results/`, deck scripts.
- **Notable behavior**: path validation, ranking policy, Markdown/CSV output contracts.
